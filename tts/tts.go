package tts

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	pgs "github.com/lyft/protoc-gen-star"
)

// ReportModule creates a report of all the target messages generated by the
// protoc run, writing the file into the /tmp directory.
type tts struct {
	*pgs.ModuleBase
	f *file
}

// New configures the module with an instance of ModuleBase
func New() pgs.Module {
	return &tts{
		ModuleBase: &pgs.ModuleBase{},
		f:          &file{},
	}
}

// Name is the identifier used to identify the module. This value is
// automatically attached to the BuildContext associated with the ModuleBase.
func (t *tts) Name() string { return "tts" }

func (t *tts) addMessage(msg pgs.Message) {
	if t.f.messageExists(msg) {
		return
	}
	var m message
	m.Name = msg.Name().String()
	for _, f := range msg.Fields() {
		m.addField(f)
	}
	t.f.Messages = append(t.f.Messages, m)
}

func (t *tts) addEnum(pgsEnum pgs.Enum) {
	if t.f.enumExists(pgsEnum) {
		return
	}
	var e enum
	e.Name = pgsEnum.Name().String()
	for _, v := range pgsEnum.Values() {
		e.Values = append(e.Values, v.Name().String())
	}
	t.f.Enums = append(t.f.Enums, e)
}

func getDoc(s string, indent int) string {
	if s == "" {
		return ""
	}
	lines := []string{}
	for _, line := range strings.Split(s, "\n") {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		lines = append(lines, line)
	}
	if len(lines) == 1 {
		return fmt.Sprintf(`/** %s */`, lines[0])
	}
	var resp string
	resp += "/**\n"
	for _, line := range lines {
		resp += strings.Repeat("\t", indent) + line + "\n"
	}
	return resp + strings.Repeat("\t", indent) + "*/"
}

// Execute is passed the target files as well as its dependencies in the pkgs
// map. The implementation should return a slice of Artifacts that represent
// the files to be generated. In this case, "/tmp/report.txt" will be created
// outside of the normal protoc flow.
func (t *tts) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	tmpl := template.Must(template.New("tts").Funcs(template.FuncMap{
		"title": strings.Title,
	}).Parse(serviceTemplate))
	for _, f := range targets {
		var bts bytes.Buffer
		for _, s := range f.Services() {
			var sd serviceData
			sd.Name = s.Name().String()
			sd.Doc = getDoc(s.SourceCodeInfo().LeadingComments(), 0)
			sd.PathPrefix = fmt.Sprintf(
				"/twirp/%s.%s/",
				f.Package().ProtoName().String(),
				sd.Name,
			)
			for _, method := range s.Methods() {
				var md methodData
				md.Name = method.Name().LowerCamelCase().String()
				md.Doc = getDoc(method.SourceCodeInfo().LeadingComments(), 1)
				md.Input = method.Input().Name().String()
				md.Output = method.Output().Name().String()
				sd.Methods = append(sd.Methods, md)
			}
			t.f.Services = append(t.f.Services, sd)
		}
		for _, msg := range f.Messages() {
			t.addMessage(msg)
			t.addMessage(msg)
		}
		for _, enum := range f.Enums() {
			t.addEnum(enum)
		}
		err := tmpl.Execute(&bts, t.f)
		if err != nil {
			t.AddError(err.Error())
			continue
		}
		out := f.Package().ProtoName().String() + ".ts"
		t.AddGeneratorFile(out, bts.String())
	}
	t.AddGeneratorFile("twirp.ts", twirpFile)
	return t.Artifacts()
}

type file struct {
	Services []serviceData
	Enums    []enum
	Messages []message
}

func (f *file) messageExists(msg pgs.Message) bool {
	for _, m := range f.Messages {
		if msg.Name().String() == m.Name {
			return true
		}
	}
	return false
}

func (f *file) enumExists(enum pgs.Enum) bool {
	for _, m := range f.Enums {
		if enum.Name().String() == m.Name {
			return true
		}
	}
	return false
}

type serviceData struct {
	Name       string
	Doc        string
	PathPrefix string
	Methods    []methodData
}

type methodData struct {
	Name   string
	Doc    string
	Input  string
	Output string
}

type enum struct {
	Name   string
	Values []string
}

type message struct {
	Name   string
	Fields []messageField
}

func (m *message) addField(field pgs.Field) {
	var f messageField
	f.Name = field.Name().LowerCamelCase().String()
	f.JSONName = field.Name().String()
	f.Type = protoTypeToTSType(field.Type())
	f.IsRepeated = field.Type().IsRepeated()
	f.IsEnum = field.Type().IsEnum()
	f.ZeroValue = f.populateZeroValue()
	m.Fields = append(m.Fields, f)
}

func (mf *messageField) populateZeroValue() string {
	switch mf.Type {
	case "boolean":
		return "false"
	case "number":
		return "0"
	case "string":
		return "''"
	}
	if mf.IsRepeated {
		return "[]"
	}
	if mf.IsEnum {
		return "''"
	}
	return "{}"
}

func protoTypeToTSType(typ pgs.FieldType) string {
	switch typ.ProtoType() {
	case pgs.EnumT:
		if typ.IsRepeated() {
			return typ.Element().Enum().Name().String()
		}
		return typ.Enum().Name().String()
	case pgs.MessageT:
		if typ.IsRepeated() {
			return typ.Element().Embed().Name().String()
		}
		return typ.Embed().Name().String()
	case pgs.BoolT:
		return "boolean"
	case pgs.Int32T, pgs.Int64T,
		pgs.SInt32, pgs.SInt64,
		pgs.UInt32T, pgs.UInt64T,
		pgs.DoubleT, pgs.FloatT:
		return "number"
	case pgs.StringT:
		return "string"
	}
	panic("unknown type: " + typ.Element().ProtoType().String())
}

type messageField struct {
	Name       string
	JSONName   string
	ZeroValue  string
	Type       string
	IsRepeated bool
	IsEnum     bool
}

func (mf messageField) ResolveType() string {
	t := mf.Type

	// if t == "Date" {
	// 	t = "string"
	// }

	if mf.IsRepeated {
		switch t {
		case "string", "number", "boolean":
			return fmt.Sprintf("(props['%s']! || []).map((v) => { return %s(v)})", mf.JSONName, strings.Title(t))
		}
		if mf.IsEnum {
			return fmt.Sprintf("(props['%s']! || []).map((v) => { return (%s)[v] })", mf.JSONName, t)
		}
		return fmt.Sprintf("(props['%s']! || []).map((v) => { return %s.fromJSON(v) })", mf.JSONName, t)
	}

	switch t {
	case "string", "number", "boolean":
		return fmt.Sprintf("%s(props['%s'] || %s)!", strings.Title(t), mf.JSONName, mf.ZeroValue)
	}

	if mf.IsEnum {
		return fmt.Sprintf("(%s)[props['%s']! || '']!", t, mf.JSONName)
	}

	return fmt.Sprintf("%s.fromJSON(props['%s']!)", t, mf.JSONName)
}

func (mf messageField) PrintType() string {
	resp := mf.Type
	if mf.IsRepeated {
		resp += "[]"
	}
	return resp
}
